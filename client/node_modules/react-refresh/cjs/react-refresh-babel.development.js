/** @license React vundefined
 * react-refresh-babel.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';



if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

function ReactFreshBabelPlugin (babel) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof babel.getEnv === 'function') {
    // Only available in Babel 7.
    var env = babel.getEnv();

    if (env !== 'development' && !opts.skipEnvCheck) {
      throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: "' + env + '". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');
    }
  }

  var t = babel.types;
  var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');
  var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');
  var registrationsByProgramPath = new Map();

  function createRegistration(programPath, persistentID) {
    var handle = programPath.scope.generateUidIdentifier('c');

    if (!registrationsByProgramPath.has(programPath)) {
      registrationsByProgramPath.set(programPath, []);
    }

    var registrations = registrationsByProgramPath.get(programPath);
    registrations.push({
      handle: handle,
      persistentID: persistentID
    });
    return handle;
  }

  function isComponentishName(name) {
    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';
  }

  function findInnerComponents(inferredName, path, callback) {
    var node = path.node;

    switch (node.type) {
      case 'Identifier':
        {
          if (!isComponentishName(node.name)) {
            return false;
          } // export default hoc(Foo)
          // const X = hoc(Foo)


          callback(inferredName, node, null);
          return true;
        }

      case 'FunctionDeclaration':
        {
          // function Foo() {}
          // export function Foo() {}
          // export default function Foo() {}
          callback(inferredName, node.id, null);
          return true;
        }

      case 'ArrowFunctionExpression':
        {
          if (node.body.type === 'ArrowFunctionExpression') {
            return false;
          } // let Foo = () => {}
          // export default hoc1(hoc2(() => {}))


          callback(inferredName, node, path);
          return true;
        }

      case 'FunctionExpression':
        {
          // let Foo = function() {}
          // const Foo = hoc1(forwardRef(function renderFoo() {}))
          // export default memo(function() {})
          callback(inferredName, node, path);
          return true;
        }

      case 'CallExpression':
        {
          var argsPath = path.get('arguments');

          if (argsPath === undefined || argsPath.length === 0) {
            return false;
          }

          var calleePath = path.get('callee');

          switch (calleePath.node.type) {
            case 'MemberExpression':
            case 'Identifier':
              {
                var calleeSource = calleePath.getSource();
                var firstArgPath = argsPath[0];
                var innerName = inferredName + '$' + calleeSource;
                var foundInside = findInnerComponents(innerName, firstArgPath, callback);

                if (!foundInside) {
                  return false;
                } // const Foo = hoc1(hoc2(() => {}))
                // export default memo(React.forwardRef(function() {}))


                callback(inferredName, node, path);
                return true;
              }

            default:
              {
                return false;
              }
          }
        }

      case 'VariableDeclarator':
        {
          var init = node.init;

          if (init === null) {
            return false;
          }

          var name = node.id.name;

          if (!isComponentishName(name)) {
            return false;
          }

          switch (init.type) {
            case 'ArrowFunctionExpression':
            case 'FunctionExpression':
              // Likely component definitions.
              break;

            case 'CallExpression':
              {
                // 